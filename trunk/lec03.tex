%
% Softheme internal lectures
%
% Formal models and methods for program semantics, correctness and verification
%
% (c) Vadim Vinnik, 2014
%
% vadim.vinnik@gmail.com
%

\documentclass[landscape]{slides}
\usepackage[landscape, margin=10mm]{geometry}

\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}

\setlength{\unitlength}{6mm}

\input{defs.tex}

\sloppy

\begin{document}

\author{В.Ю.\,Винник}

\title{%
Формальные модели\\%
семантики и корректности,\\%
методы спецификации\\%
и верификации программ.\\
Часть~3}

\date{Softheme, 04.07.2014 н.э}

\maketitle

\begin{slide}
        \begin{center}
                \begin{LARGE}
                        TODO: Сюда вставить какой-то смешной и умный афоризм о теории и практике
                \end{LARGE}
        \end{center}
\end{slide}

\begin{slide}
        Важные вспомогательные сведения
        \begin{itemize}
                \item Предикат~$P(x)$ определяет множество~$M=\{x\mid P(x)\}$ и наоборот~-- множество~$M$
                        определяет предикат~$P(x) = x\in M$.
                \item Импликация есть логическая операция (т.е. $P\implies Q$ есть, в свою очередь,
                        придикат, который может быть истинным или ложным), а также моделирует отношение логического
                        следования между предикатами (из~$P$ следует~$Q$ т.т.т., когда предикат~$P\implies Q$~-- истинный).
                \item Отношение логического следования может рассматриваться как отношение частичного порядка
                        над предикатами: предикат~$P$ "<меньше">, чем~$Q$, если и только если~$P\implied Q$.
                \item \emph{Частичный} порядок означает, что не все предикаты сравнимы между собой: например,
                        если~$P=(x>10)$, а $Q=(x<30)$, то $P\not\implied Q$ и $Q\not\implied P$.
        \end{itemize}
\end{slide}

\begin{slide}
        Важные вспомогательные сведения
        \begin{itemize}
                \item "<Меньше"> для предикатов означает "<слабее">.
                \item Наименьший из всех предикатов~-- тождественно истинный предикат~$\true$, наибольший~--
                        тождественно ложный~$\false$.
                \item Из свойства дизъюнкции (если $R=P\lor Q$, то $R\implied P$ и $R\implied Q$) следует, что
                        дизъюнкция есть \emph{точная нижняя грань} двух предикатов ($R$~есть наибольший из всех
                        предикатов, меньших, чем оба~$P$ и~$Q$), т.е. $P\lor Q = \infinum\{P, Q\}$.
                \item Дуальным образом, конъюнкция есть \emph{точная верхняя грань} двух предикатов,
                        $P\land Q = \supremum\{P, Q\}$.
        \end{itemize}
\end{slide}

\begin{slide}
        Repetitio est mater studiorum

        \begin{center}
                \begin{picture}(8,10)
                        \put(0,8){\makebox(8,2)[c]{\shortstack[c]{Исходные данные, начальное состояние памяти}}}
                        \put(4,8){\vector(0,-1){2}}
                        \put(0,4){\framebox(8,2)[c]{Программа}}
                        \put(4,4){\vector(0,-1){2}}
                        \put(0,0){\makebox(8,2)[c]{\shortstack[c]{Результаты, заключительное состояние памяти}}}
                \end{picture}
        \end{center}

        Метод хоаровских троек

        \begin{itemize}
                \item Спецификация~-- предусловие и постусловие.
                \item Предусловие~-- налагаемое на начальное состояние памяти.
                \item Постусловие~-- налагаемое на заключительное состояние.
        \end{itemize}
\end{slide}

\begin{slide}
        Repetitio est mater studiorum

        Полная корректность программы относительно спецификации
                        \[
                                \tripleT{P}{S}{Q}
                        \]
        означает: если начальное состояние памяти удовлетворяет предусловию,
        то программа завершается, причём её заключительное состояние
        удовлетворяет постусловию.

        Если исходные данные нарушают предусловие, программа имеет право
        делать что угодно, никакое её поведение не подтвердит и не опровергнет
        её корректность.
\end{slide}

\begin{slide}
        Неадекватности хоаровской модели частичной корректности

        Всегда зависающая программа выглядит универсальным исполнителем желаний: для любого~$Q$
        \[
                \tripleP{\true}{\hang}{Q} .
        \]

        Всегда зависающая программа является правым нулём последовательной композиции
                        \[
                                S ; \hang = \hang ,
                        \]
        но не является левым нулём:
                        \[
                                \hang ; S = S .
                        \]

        Общий вывод: хоаровская модель частичной корректности~-- слишком грубый инструмент для исследования
        некоторых существенных свойств реальных программ.
        
        Результаты, выводимые с её помощью, несут не только
        адекватное знание об исследуемой программе, но и сильный отпечаток самого этого инструмента.
\end{slide}

\begin{slide}
        На пути к лучшей модели

        Программа может удовлетворять многим спецификациям:
        \begin{eqnarray*}
                &\tripleT{x=0}{x\assign x\times 2}{x=0}, \\
                &\tripleT{x>10}{x\assign x\times 2}{x>20}, \\
                &\tripleT{\true}{x\assign x\times 2}{x\ \mathrm{mod}\ 2 = 0} .
        \end{eqnarray*}

        Зафиксируем постусловие, так как оно в реальном процессе определено заказчиком.
        Программа может гарантировать его достижение при многих разных предусловиях:
        \begin{eqnarray*}
                &\tripleT{x>100 \land x < 200}{x\assign x\times 2}{x>20}, \\
                &\tripleT{x>80 \land x\,\mathrm{mod}\,4=0}{x\assign x\times 2}{x>20}, \\
                &\tripleT{x=30}{x\assign x\times 2}{x>20}.
        \end{eqnarray*}
\end{slide}

\begin{slide}
        Пусть~$M$~-- множество всех таких предусловий, при которых программа~$S$ гарантирует достижение
        постусловия~$Q$:
        \[
                M = \{ P \mid \tripleT{P}{S}{Q} \} .
        \]

        Существует и единственно такое предусловие~$R\in M$, что
        \[
                P \implied R\quad\text{для всех}\ P\in M .
        \]

        Это дизъюнкция всех предусловий~$P\in M$, а также наибольший элемент множества~$M$:
        \[
                R = \bigvee_{S\in M} S = \max M.
        \]
        
        Называем~$R$ \emph{слабейшим предусловием программы~$S$ относительно постусловия~$Q$}
        и обозначаем
        \[
                R = \wpof{S}{Q} .
        \]
\end{slide}

\begin{slide}
        Теперь семантика программы~$S$ моделируется функционалом (преобразователем предикатов)~$\wpof{S}{\cdot}$,
        который всякому желаемому постусловию~$Q$ ставит в соответствие самое слабое предусловие~$P$, которое
        гарантирует, что программа~$S$ завершится и даст правильный (удовлетворяющий~$Q$ результат).

        Примеры:
        \begin{eqnarray*}
                &\wpof{x\assign x+1}{x>10} = (x > 9) ,\\
                &\wpof{x\assign x+1}{x\, \mathrm{mod}\, 2 = 0} = (x\, \mathrm{mod}\, 2 = 1) ,\\
                &\wpof{x\assign x\times 2}{x = 7} = \false .
        \end{eqnarray*}
\end{slide}

\begin{slide}
        Общие свойства функционала~$\wpsign$:

        \begin{itemize}
                \item Закон исключённого чуда:
                        \[
                                \wpof{S}{\false} = \false .
                        \]
                \item Монотонность:
                        \[
                                (Q_1\implies Q_2)
                                \implies
                                (\wpof{S}{Q_1} \implies \wpof{S}{Q_2}) .
                        \]
                \item Дистрибутивность конъюнкции:
                        \[
                                \wpof{S}{Q_1} \land \wpof{S}{Q_2} = \wpof{S}{Q_1 \land Q_2} .
                        \]
        \end{itemize}
\end{slide}

\begin{slide}
        Дистрибутивность дизъюнкции в общем случае:
        \[
                \wpof{S}{Q_1} \lor \wpof{S}{Q_2} \implies \wpof{S}{Q_1 \lor Q_2} .
        \]
        Контрпример для~$\implied$: пусть
        \begin{eqnarray*}
                &S = (x \assign random(2)),\\
                &Q_1 = (x = 0),\\
                &Q_2 = (x = 1),
        \end{eqnarray*}
        тогда
        \begin{eqnarray*}
                &Q_1 \lor Q_2 = \true.\\
                &\wpof{S}{Q_1 \lor Q_2} = \true .
        \end{eqnarray*}
        Однако
        \[
                \wpof{S}{Q_1} = \wpof{S}{Q_2} = \false .
        \]

        Дистрибутивность дизъюнкции в обе стороны работает для детерминированных программ и только для них!
\end{slide}

\begin{slide}
        Важнейшие частные случаи:

        \begin{itemize}
                \item Пустая программа:
                        \[
                                \wpof{\nop}{Q} = Q .
                        \]
                \item Всегда зависающая программа: для любого~$Q$
                        \[
                                \wpof{\hang}{Q} = \false .
                        \]
                \item Условие завершимости программы:
                        \[
                                \wpof{S}{\true} .
                        \]
        \end{itemize}
\end{slide}

\begin{slide}
        Последовательная композиция

        \begin{center}
                \begin{picture}(18,2)
                        \put(0,0){\makebox(2,2)[c]{\shortstack[c]{$x_0$}}}
                        \put(2,1){\vector(1,0){2}}
                        \put(4,0){\framebox(2,2)[c]{$S_1$}}
                        \put(6,1){\vector(1,0){2}}
                        \put(8,0){\makebox(2,2)[c]{\shortstack[c]{$x_1$}}}
                        \put(10,1){\vector(1,0){2}}
                        \put(12,0){\framebox(2,2)[c]{$S_2$}}
                        \put(14,1){\vector(1,0){2}}
                        \put(16,0){\makebox(2,2)[c]{\shortstack[c]{$x_2$}}}
                \end{picture}
        \end{center}

        Результат первой программы~-- вход второй. Условие, наложенное на промежуточное состояние,
        есть постусловие для~$S_1$ и предусловие для~$S_2$:
        \[
                \wpof{S_1;S_2}{Q} = \wpof{S_1}{\wpof{S_2}{Q}} .
        \]
\end{slide}

\begin{slide}
        Ветвление
        \begin{center}
                \begin{picture}(24,9)(-12,-9)
                        \put(-2,0){\makebox(4,1)[c]{\shortstack[c]{$\{P\}$}}}
                        \put(0,0){\vector(0,-1){1}}
                        \put(-4,-2){\line(4,1){4}}
                        \put(-4,-2){\line(4,-1){4}}
                        \put(4,-2){\line(-4,-1){4}}
                        \put(4,-2){\line(-4,1){4}}
                        \put(-4,-4){\makebox(8,4)[c]{\shortstack[c]{$b$}}}
                        \put(-5,-0.5){\makebox(0,0)[rt]{{$\{P \land b\}$}}}
                        \put(5,-0.5){\makebox(0,0)[lt]{{$\{P \land \neg b\}$}}}
                        \put(-4,-2){\line(-1,0){4}}
                        \put(-8,-2){\vector(0,-1){2}}
                        \put(-12,-6){\framebox(8,2)[c]{\shortstack[c]{$S_1$}}}
                        \put(-8,-6){\line(0,-1){2}}
                        \put(-8,-8){\line(1,0){8}}
                        \put(4,-2){\line(1,0){4}}
                        \put(-2,-8.9){\makebox(4,4)[c]{\shortstack[c]{$\{Q\}$}}}
                        \put(8,-2){\vector(0,-1){2}}
                        \put(4,-6){\framebox(8,2)[c]{\shortstack[c]{$S_2$}}}
                        \put(8,-6){\line(0,-1){2}}
                        \put(8,-8){\line(-1,0){8}}
                        \put(0,-8){\vector(0,-1){1}}
                \end{picture}
        \end{center}
        \begin{eqnarray*}
                &IF = (\ifelse{b}{S_1}{S_2}) , \\
                &\wpof{IF}{Q} =
                (b \implies \wpof{S_1}{Q}) \land
                (\neg b \implies \wpof{S_2}{Q}) .
        \end{eqnarray*}
\end{slide}

\begin{slide}
        Циклическая композиция $DO = \while{b}{S}$

        Любое разумное постусловие обязательно включает в себя~$\neg b$:
        \[
                \wpof{DO}{b} = \false ,
        \]
        Поэтому его можно представить в виде
        \[
                Q = I\land \neg b .
        \]

        Метод последовательных приближений. В предельном случае
        цикл может завершиться, не сделав ни одной итерации~--
        если условие продолжения~$b$ изначально ложно. Условие этого:
        \[
                P_0 = \wpof{\nop}{Q} = Q = I\land \neg b .
        \]
\end{slide}

\begin{slide}
        Цикл может завершиться за одну итерацию или менее:
        \[
                P_1 = P_0 \lor \wpof{S}{Q} = P_0 \lor \wpof{S}{P_0} .
        \]

        Пусть $P_k$~-- условие того, что цикл завершается за не более, чем~$k$ итараций.
        Тогда
        \[
                P_{k+1} = P_k \lor \wpof{S}{P_k} .
        \]

        Теперь условие того, что цикл завершится за какое-либо число итераций, есть
        \[
                \wpof{DO}{Q} = \bigvee_{n=0}^{\infty} P_k .
        \]
\end{slide}

\begin{slide}
        Метод неподвижной точки

        Неподвижной точкой функции~$f$ называется такой объект~$x$, что
        \[
                x = f(x) .
        \]
        Если область определения функции~$f$ представляет собой полную решётку и~$\bot$ есть её
        наименьший элемент, то наименьшая неподвижная точка~$f$ строится методом последовательных
        приближений:
        \begin{eqnarray*}
                &x_0 = \bot,\\
                &x_{k+1} = f(x_k),\\
                &x^* = \supremum \{ x_k \mid k=0,\ldots,\infty\} .
        \end{eqnarray*}

        Из определения цикла (см. также лекцию~2) следует, что
        \[
                DO = \ifthen{b}{S; DO} ,
        \]
        следовательно, цикл есть неподвижная точка функционала
        \[
                IF(X) = \ifthen{b}{X; DO} .
        \]
\end{slide}

\begin{slide}
        Непрерывность

        Функция~$f$, определённая на полной решётке, называется непрерывной, если она сохраняет пределы.
        Пусть
        \[
                x_0\prec x_1\prec\ldots\prec x_k\prec x_{k+1}\prec\ldots
        \]
        Тогда непрерывность означает, что
        \[
                f\left(\sup{x_k}\right) = \sup f\left(x_k\right) .
        \]

        Пример функции, не являющейся непрерывной:
        \begin{eqnarray*}
                &f(1) = 1 ,\\
                &f(x) = 0\ \text{при}\ x<1.
        \end{eqnarray*}
        Пусть $x_k = \frac{k}{k+1}$. Очевидно, что~$x_k < 1$, поэтому $f(x_k) = 0$, и
        \[
                \sup f(x_k) = 0 .
        \]
        Однако $\sup x_k = 1$, поэтому
        \[
                f(\sup x_k) = 1 .
        \]
\end{slide}

\begin{slide}
        Метод неподвижной точки работает только для непрерывных\\функций!

        К счастью, функционалы~$\wpof{S}{\cdot}$ для всех базовых операторов и всех программ,
        которые возможно построить из них с помощью композиций, непрерывны.

        Условие непрерывности означает ограничение на максимально возможную недетерминированность
        программ. Невозможна программа~$\chaos$, завершающаяся в абсолютно непредсказуемом состоянии.

        В противном случае, если $Q_k\ne\true$ и $\sup Q_k = \true$, то
        \[
                \wpof{\chaos}{\sup Q_k} = \true,
        \]
        но
        \[
                \sup \wpof{\chaos}{Q_k} = \false.
        \]
\end{slide}

\begin{slide}
\end{slide}

\begin{slide}
\end{slide}

\begin{slide}
\end{slide}

\end{document}
