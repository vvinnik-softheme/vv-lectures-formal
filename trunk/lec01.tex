%
% Softheme internal lectures
%
% Formal models and methods for program semantics, correctness and verification
%
% (c) Vadim Vinnik, 2014
%
% vadim.vinnik@gmail.com
%

\documentclass[landscape]{slides}
\usepackage[landscape, margin=10mm]{geometry}

\usepackage{amssymb}
\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}

\begin{document}

\author{В.Ю.\,Винник}

\title{%
Формальные модели\\%
семантики и корректности,\\%
методы спецификации\\%
и верификации программ}

\date{Softheme, 27.05.2014 н.э}

\maketitle

\begin{slide}
\begin{center}
\begin{LARGE}
Нет ничего практичнее\\%
хорошей теории
\end{LARGE}
\end{center}
\end{slide}

\begin{slide}
Зачем программированию формальные методы?
\begin{itemize}
\item Программирование есть (в том числе и) инженерная дисциплина;
\item Самолёты, мосты, электросети просчитываются математически;
\item Сложность программных изделий не ниже сложности автомобиля
        или самой ЭВМ;
\item Однако при изготовлении программ преобладает "<ремесленный">
        подход;
\item Решения основываются на здравом смысле, предшествующем опыте,
        удобстве, личных предпочтениях.
\end{itemize}
\end{slide}

\begin{slide}
Формальные методы и обеспечение корректности программ
\begin{itemize}
\item "<Тестирование программы может весьма эффективно продемонстрировать
        наличие ошибок, но безнадёжно неадекватно для демонстрации их
        отсутствия"> (Э.\,Дейкстра)
\item Формальные методы позволяют \emph{доказывать} правильность программм
        математически (формальная верификация);
\item Еще лучше доказывать правильность программы до её создания~-- текст
        программы может из доказательства извлечь машина (формальный синтез).
\item В пределе~-- переход от написания программ к написанию спецификаций,
        оставив синтез программного текста машине.
\end{itemize}
\end{slide}

\begin{slide}
Связь теории и практики программирования
\begin{itemize}
\item Естественные науки изучают предмет, данный в готовом виде;
\item Инженерия создаёт новые объекты, пользуясь моделями естественных наук;
\item Математика создаёт свой предмет по ходу изучения его;
\item Математическая теория программирования не только изучает свойства
        программирования в его нынешнем состоянии, но и направляет его
        дальнейшее развитие;
\item Написать программу "<Hello World"> можно и без привлечения
        матмоделей, а создать новый каркас (framework), язык или
        парадигму~-- нет.
\end{itemize}
\end{slide}

\begin{slide}
Прецедент~-- синтаксическая революция
\begin{itemize}
\item В 1950--1960-х гг. создание каждого транслятора было серьёзной проблемой;
\item Без матмодели~-- подход к каждому языку, оператору, синтаксической конструкции "<в розницу">;
\item Каждый транслятор привносил свой диалект языка;
\item Математический аппарат (кс-грамматики, БНФ) позволил
        решить весь класс проблем "<оптом">;
\item Метасистемный переход по В.Ф.\,Турчину;
\item Эталон: синтаксис новых языков должен быть таким, чтобы хорошо отображаться в БНФ.
\end{itemize}
\end{slide}

\begin{slide}
Ожидание семантической революции
\begin{itemize}
\item Средства автоматизированного анализа программ;
\item Раннее обнаружение семантических ошибок;
\item Автоматизированный синтез программ;
\item Разработка более изящных языков, парадигм и технологий программирования.
\end{itemize}
\end{slide}

\begin{slide}
Формальные методы в повседневной работе?
\begin{itemize}
\item Методы верификации громоздки и неудобны;
\item Доказательство корректности элементарной программы
        длиннее самой программы;
\item Автоматизации поддаются плохо: в общем случае проблема
        неразрешима (слава Гёделю);
\item Формальное доказательство корректности проводится редко\ldots
\end{itemize}
\end{slide}

\begin{slide}
Однако\ldots
Повышение культуры программирования!

Постигший фундаментально-математическую сторону программирования
не станет
"<просто ``лепить команды'', т.е. выдавать тексты, основанные на неубедительных
предположениях, несостоятельность которых может выявиться после первого же
противоречащего примера"> (Э.\,Дейкстра)

Грамотно говорящий на родном языке может не задумываться по поводу каждого
слова о том, подлежащее оно или сказуемое, и в каком падеже оно употребляется.

Усвоить правило~-- значит забыть его и применять, не осознавая.
\end{slide}

\begin{slide}
Семиотика~-- общая наука о знаковых системах.

\begin{center}
\begin{tabular}{|l|l|l|}
        \hline
        Синтактика & Знак -- знак    & Как пишется         \\ \hline
        Семантика  & Знак -- объект  & Что означает        \\ \hline
        Прагматика & Знак -- субъект & Зачем употребляется \\ \hline
\end{tabular}
\end{center}

Г.\,Фреге: Знак --- смысл --- значение

Синтаксис ЯП~-- набор ключевых слов, правила составления выражений и
конструкций. Зависит от конкретного ЯП.

Семантические знания: что такое переменная, вызов функции и возврат
значения, класс, объект и наследование. Общие для целых классов ЯП.

Прагматика программных текстов: (1)~решить конкретную задачу;
(2)~донести идею решения до других людей.
\end{slide}

\begin{slide}
Методологические замечания
\begin{itemize}
\item Наука НЕ познаёт "<Истину"> (с Большой Буквы);
\item Наука только строит модели действительности;
\item Некоторые модели более адекватны, чем другие;
\item Всякая модель имеет свою область применимости.
\end{itemize}
Поэтому ВСЕ теории и модели программирования страдают изъянами и
не охватывают всего явления.
\end{slide}

\setlength{\unitlength}{6mm}
\begin{slide}
Программа как чёрный ящик принимает исходные данные и выдаёт результаты

\begin{center}
\begin{picture}(8,10)
\put(0,8){\makebox(8,2)[c]{\shortstack[c]{Исходные данные, начальное состояние памяти}}}
\put(4,8){\vector(0,-1){2}}
\put(0,4){\framebox(8,2)[c]{Программа}}
\put(4,4){\vector(0,-1){2}}
\put(0,0){\makebox(8,2)[c]{\shortstack[c]{Результаты, заключительное состояние памяти}}}
\end{picture}
\end{center}

Описать семантику программы~-- значит описать свойства отображения исходных
данных на результаты.

Задать спецификацию программы~-- значит описать желаемое соотношение между
исходными данными и результатами.

Описать семантику управляющей конструкции~-- значит показать, как строится
семантика составной программы из семантики программ, охваченных ею.
\end{slide}

\begin{slide}
Метод Ч.\,Э.\,Р.\,Хоара (метод хоаровских троек)
\begin{itemize}
\item Предусловие~-- налагаемое на начальное состояние памяти.
\item Постусловие~-- налагаемое на заключительное состояние.
\item Спецификация~-- предусловие и постусловие.
\item Пред- и постусловие выражены предикатами, в которые входят
        имена переменных программы.
\end{itemize}
\end{slide}

\newcommand{\true}{\mathbf{True}}
\newcommand{\false}{\mathbf{False}}
\newcommand{\implies}{\Rightarrow}

\begin{slide}
Корректность программы относительно спецификации:
\begin{itemize}
\item Полная: если начальное состояние памяти удовлетворяет предусловию,
        то программа завершается, причём её заключительное состояние
        удовлетворяет постусловию.
        \[
                [P] \  S \  [Q] .
        \]
\item Частичная: если начальное состояние памяти удовлетворяет предусловию,
        и если программа завершается, то её заключительное состояние
        удовлетворяет постусловию.
        \[
                \{P\} \  S \  \{Q\} .
        \]
\item Если исходные данные нарушают предусловие, программа имеет право
делать что угодно, никакое её поведение не подтвердит и не опровергнет
её корректность.
\end{itemize}
\end{slide}

\begin{slide}
\begin{itemize}
\item Частичная корректность~-- программа имеет право не дать
никакого результата, лишь бы не дала неправильный.
\item Частичная корректность~-- ни один запуск программы не даст свидетельства
её некорректности (презумпция невиновности).
\item Программа, зависающая на любых исходных данных, корректна (в частичном смысле)
относительно любой спецификации.
\item Всегда зависающая программа (в модели частичной корректности)~-- это универсальный
решатель любых задач!
\item Если такая программа завершится, она выполнит любое желание. Но она не завершится
никогда, поэтому её нельзя будет поймать на невыполнении желания.
\end{itemize}
\end{slide}

\begin{slide}
Примеры спецификаций
\begin{itemize}
\item Нахождение максимума $c$ из значений двух переменных $a$, $b$:
        \[
                [a = \alpha \land b = \beta]
                \ S \ 
                [
                        c \geqslant \alpha \land
                        c \geqslant \beta \land
                        (c = \alpha \lor c = \beta)
                ] .
        \]
\item Обмен значениями переменных $a$ и $b$
        \[
                [a = \alpha \land b = \beta]
                \ S \ 
                [a = \beta \land b = \alpha] .
        \]
\item Нахождение наибольшего общего делителя $c$ из значений двух переменных $a$, $b$:
        \[
                [a = \alpha \land b = \beta]
                \ S \ 
                [
                        P(c) \land
                        \forall \xi : P(\gamma) \implies \gamma \leqslant c
                ] ,
        \]
        где через $P(\xi)$ обозначен предикат "<$\xi$ делит $\alpha$ и $\beta$">:
        \[
                P(\xi) = (\exists \delta, \varepsilon : \alpha = \delta\cdot \xi \land \beta = \varepsilon\cdot \xi).
        \]
\end{itemize}
\end{slide}

\begin{slide}
Общие свойства спецификаций и корректности
\begin{itemize}
\item Требование завершимости программы~$S$ на исходных данных из~$P$:
        \[
                [P] \  S \  [\true] .
        \]
\item Требование незавершимости:
        \[
                \{P\} \  S \  \{\false\} .
        \]
\item Матмодель частичной корректности удобнее, поэтому анализ полной коррректности
        разбивают на две задачи: доказательство частичной корректности и отдельно
        доказательство завершимости:
        \[
                \left(\{P\} S \{Q\}\right)
                \land 
                \left([P] S [\true]\right)
                \implies
                \left([P] S [Q]\right) .
        \]
\end{itemize}
\end{slide}

\begin{slide}
\begin{itemize}
\item Тавтологии~-- тождественно истинные спецификации:
        \[
                \{P\}\  S \  \{\true\} ,
                \quad
                \{\false\} \ S \ \{Q\} .
        \]
\item Законы консеквенции
        \[
                \frac
                {
                        P \implies R, \  \{R\} \  S \  \{Q\}
                }
                {
                        \{P\} \  S \  \{Q\}
                } ,
                \qquad
                \frac
                {
                        \{P\} \  S \  \{R\}, \  R \implies Q
                }
                {
                        \{P\} \  S \  \{Q\}
                }
        \],
        усиление пред- и ослабление постусловия.
\item Законы дистрибутивности
        \[
                \frac
                {
                        \{P_1\} \  S \  \{Q\}, \  \{P_2\} \  S \  \{Q\}
                }
                {
                        \{P_1 \lor P_2\} \  S \  \{Q\}
                },
                \qquad
                \frac
                {
                        \{P\} \  S \  \{Q_1\}, \  \{P\} \  S \  \{Q_2\}
                }
                {
                        \{P\} \  S \  \{Q_1 \land Q_2\}
                },
        \]
        работают в обе стороны~-- в силу законов консеквенции
\end{itemize}
\end{slide}

\newcommand{\nop}{\mathrm{nop}}
\newcommand{\hang}{\mathrm{hang}}
\begin{slide}
Две самые важные программы
\begin{itemize}
\item Пустой оператор
        \[
                \{P\} \  \nop \  \{P\} .
        \]
\item Зависание
        \[
                \{P\} \  \hang \  \{\false\} .
        \]
\end{itemize}
для любого $P$.
\end{slide}

\begin{slide}
\end{slide}

\begin{slide}
\begin{center}
\begin{LARGE}
Теория, мой друг, суха,\\Но зеленеет жизни древо
\end{LARGE}
\end{center}

\begin{flushright}
\emph{Часть силы той, что без числа\\Творит добро, всему желая зла}
\end{flushright}
\end{slide}

\end{document}
л
